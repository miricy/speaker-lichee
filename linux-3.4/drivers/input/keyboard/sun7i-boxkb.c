/** This program is free software; you can redistribute it and/or modify* it under the terms of the GNU General Public License as published by* the Free Software Foundation; either version 2 of the License, or* (at your option) any later version.** This program is distributed in the hope that it will be useful,* but WITHOUT ANY WARRANTY; without even the implied warranty of* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the* GNU General Public License for more details.** You should have received a copy of the GNU General Public License* along with this program; if not, write to the Free Software** Copyright (c) 2011**/#include <linux/module.h>#include <linux/init.h>#include <linux/input.h>#include <linux/delay.h>#include <linux/types.h>#include <linux/slab.h>#include <linux/interrupt.h>#include <linux/keyboard.h>#include <linux/ioport.h>#include <linux/gpio.h>#include <asm/irq.h>#include <asm/io.h>#include <linux/timer.h> #include <mach/sys_config.h>#include <linux/kthread.h>#include <linux/platform_device.h>#ifdef CONFIG_HAS_EARLYSUSPEND	#include <linux/pm.h>	#include <linux/earlysuspend.h>#endif//log#define print_err(format,args...)  do{ printk(KERN_ERR format,##args);}while(0)#define print_warn(format,args...)  do{ printk(KERN_WARN format,##args);}while(0)#define print_debug(format,args...)  do{ printk(format,##args);}while(0)#define BOX_KEYBOARD_SHORT_PRESS 0x01#define BOX_KEYBOARD_LONG_PRESS  0x02#define LONG_PRESS (1)#define INPUT_DEV_NAME	("box-keyboard")#define KEY_MAX_CNT  8static 	struct input_dev *boxkeydev;static struct task_struct *check_task;int gpio_input[8];bool gpio_request_success = false;script_item_u *list = NULL;int pio_cnt = 0;int input_cnt = 0;//int eint_cnt = 0;enum {	KEYDOWN = 0,	KEYUP   = 1,};enum {	PIO_INTUP  = 0,	PIO_OUTPUT = 1,	PIO_EINT   = 2,};static unsigned int box_scankeycodes[KEY_MAX_CNT]={	[0 ] = KEY_PE9,       	[1 ] = KEY_PE10,      	[2 ] = KEY_MENU,         	[3 ] = KEY_SEARCH,       	[4 ] = KEY_HOME,   	[5 ] = KEY_VOLUMEDOWN, 	[6 ] = KEY_ENTER,        	[7 ] = KEY_VOLUMEUP,};int read_key(int index){	int data = -1;	data = __gpio_get_value(list[gpio_input[index]].gpio.gpio);	return data;}static int box_keyboard_check_task(void *arg){	bool press_short = false;	bool report_long  = true; // if want to report long press	long int press_cnt  = 0;	int data = -1;	int mdata = -1;	int t=0;	if(list != NULL){		int j = 0;		for(j=0; j < pio_cnt; j++)		{			if(list[j].gpio.mul_sel == PIO_INTUP){				// request gpio				if(0 != gpio_request(list[j].gpio.gpio, NULL)){					print_err("%s:request gpio %d failed\n",__func__,list[j].gpio.gpio);					continue;				}				// config gpio input				if(0 != gpio_direction_input(list[j].gpio.gpio)){					print_err("%s:set gpio %d input failed\n",__func__,list[j].gpio.gpio);					gpio_free(list[j].gpio.gpio);					continue;;				}				gpio_input[input_cnt++] = j;				print_err("keycode %d = %d\n",input_cnt-1,j);			}		}	}	if(input_cnt == 0)		return -EINVAL;	gpio_request_success = true;    while(1){		if(kthread_should_stop()) break;		for(t=0; t< input_cnt; t++)		{			data = read_key(t);			//print_err("#data = %d\n",data);			if(data == KEYDOWN){				msleep(20);				mdata = read_key(t);				print_err("#mdata = %d\n",mdata);			}		#if LONG_PRESS			if(mdata == KEYUP){				press_short = true;				print_err("%s:short true\n",__func__);			}else if(mdata == KEYDOWN){				while(mdata != KEYUP){					print_err("%s:long press\n",__func__);					// report long press event down					input_report_key(boxkeydev, box_scankeycodes[gpio_input[t]], 1);					input_sync(boxkeydev);					msleep(20);					mdata = read_key(t);					press_cnt++;				}			}			if(press_cnt > 5 && mdata == KEYUP){				if(report_long){					// report long press event up					print_err("%s:long press up.\n",__func__);					input_report_key(boxkeydev, box_scankeycodes[gpio_input[t]], 0);					input_sync(boxkeydev);					press_cnt = 0;					mdata = -1;				}			}else if(press_cnt > 0){				press_short = true;			}			// report short press event			if(press_cnt){				print_err("%s:short press\n",__func__);				input_report_key(boxkeydev, box_scankeycodes[gpio_input[t]], 1);				input_sync(boxkeydev);				msleep(100);				input_report_key(boxkeydev, box_scankeycodes[gpio_input[t]], 0);				input_sync(boxkeydev);				press_short = false;				mdata = -1;				press_cnt = 0;			}		#else				//print_err("%s: define LONG_PRESS 0\n",__func__);				if(mdata == KEYUP){					input_report_key(boxkeydev, box_scankeycodes[gpio_input[t]], 1);					input_sync(boxkeydev);					msleep(100);					input_report_key(boxkeydev, box_scankeycodes[gpio_input[t]], 0);					input_sync(boxkeydev);					mdata = -1;				}else if(mdata == KEYDOWN){					input_report_key(boxkeydev, box_scankeycodes[gpio_input[t]], 1);					input_sync(boxkeydev);					mdata = -1;				}		#endif		}		if(data == KEYUP){			msleep(300);			//print_err("%s:sleep.\n",__func__);		}	}	return 0;}static int box_keyboard_init(void){	int ret = -1;	int i = 0;	bool need_thread = false;	//script_item_value_type_e type;    boxkeydev = input_allocate_device();	if (!boxkeydev){		//kfree(boxkeydev);		print_err("%s:out of memory.\n",__func__);		return -ENODEV;	}	boxkeydev->name = INPUT_DEV_NAME;	boxkeydev->phys = "swkbd/input0";	boxkeydev->id.bustype = BUS_HOST;	boxkeydev->id.vendor = 0x0001;	boxkeydev->id.product = 0x0001;	boxkeydev->id.version = 0x0100;	boxkeydev->open = NULL;	boxkeydev->close = NULL;	set_bit(EV_KEY, boxkeydev->evbit);	set_bit(EV_REL, boxkeydev->evbit);		for(i=0; i< KEY_MAX_CNT; i++)	{		set_bit(box_scankeycodes[i],boxkeydev->keybit);	}	ret = input_register_device(boxkeydev);	if(ret){		print_err("%s:Unable to Register the box keyboard\n",__func__);	}	pio_cnt = script_get_pio_list("key_board",&list);	/*if(SCIRPT_ITEM_VALUE_TYPE_PIO != type){		print_err("%s:get gpio fail\n",__func__);		//goto err_init;	}	*/	if(pio_cnt == 0){		print_err("get key_board gpio list fail\n");		goto err_init;	}else{		print_err("get key_board gpio count = %d\n",pio_cnt);	}	if(list != NULL){		int j =0;		for(j =0; j < pio_cnt; j++)		{			if(list[j].gpio.mul_sel == PIO_INTUP){				need_thread = true;				print_err("need_thread = %d,j = %d\n",need_thread,j);				break;			}		}	}	//print_err("#gpio = %d\n",val.gpio.gpio);	if(need_thread){		check_task = kthread_run(box_keyboard_check_task,NULL,"box_keyboard");		if(IS_ERR(check_task)){			print_err("%s:Unable to start main task.\n",__func__);			ret = PTR_ERR(check_task);			check_task = NULL;			return ret;		}	}	// request interrupt gpio	    return 0;err_init:	input_unregister_device(boxkeydev);	kfree(boxkeydev);	return ret;}static void box_keyboard_exit(void){	if(check_task){        kthread_stop(check_task);        check_task = NULL;    }	if(gpio_request_success){		int n = 0;		for(n=0; n<input_cnt; n++)		{			gpio_free(list[gpio_input[n]].gpio.gpio);		}	}	input_unregister_device(boxkeydev);	kfree(boxkeydev);}module_init(box_keyboard_init);module_exit(box_keyboard_exit);MODULE_DESCRIPTION("box keyboard driver");MODULE_AUTHOR("linjunqian");MODULE_LICENSE("GPL");